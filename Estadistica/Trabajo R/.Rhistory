# 1
x <- c(7,11,6,3)
y <- c(7,9,7,9)
solve(x,y)
solve(y)
y <- c((7,9,7,9),(3,4,5,6))
matriz <- matrix(1:12, nrow = 4, ncol = 3)
View(matriz)
matriz <- matrix(1:12, nrow = 3, ncol = 4)
View(matriz)
matriz <- matrix(1:12, nrow = 3, ncol = 4, byrow = true)
matriz <- matrix(1:12, nrow = 3, ncol = 4, byrow = 1)
View(matriz)
tabla <- table(grado, genero, datos)
tabla <- table("grado", "genero", "datos")
tabla <- table(y, x, matriz)
# Un dato atómico es lo mismo que un vector de longitud 1
x <- 5
# Definición de vectores y composición
x <- c(1, 2)
y <- c(3, 6, 7, 11)
z <- c(x, y)
# Vectores lógicos y de cadenas
a <- c(T, F, T)
b <- c("dsd", "fdf")
# Secuencias
1:10
-10:-1
seq(1, 10, 2)
# Subsetting en sus dos formas
z <- 11:20
z[c(3, 4, 6)]
z[c(T, T, F, F, F, F, T, T, T, T)]
# Cuando pido índices que no existen recibo NA
x[2:5]
# Definición de listas
ll <- list(2, 3, "vc", "dfs", T, F)
# Esto es una sublista
ll[1]
# Esto extrae un valor de una lista
ll[[1]]
data("AirPassengers")
ap <- as.vector(AirPassengers)
# operaciones básicas
length(ap)
sum(ap)
mean(ap)
sort(ap)
# Mediana
median(ap)
mean(sort(ap)[72:73])
# Moemento ordinario de orden 2
mean(ap^2)
# Momento central de orden 1 = 0
mean(ap-mean(ap))
# Varianza
mean((ap - mean(ap))^2)
# Varianza
mean((ap - mean(ap))^2)
mean(ap^2) - mean(ap)^2
sum((ap - mean(ap))^2)/length(ap)
var(ap) * (length(ap)-1) / length(ap)
# cuasivarianza
sum((ap - mean(ap))^2) / (length(ap)-1)
var(ap)
# Desviación típica
sqrt(mean(ap^2) - mean(ap)^2)
sd(ap) * sqrt((length(ap)-1) / length(ap))
# Funciones para calcular momentos
Mord   <- function(data, n) mean(data^n)
Mcentr <- function(data, n) mean((data - mean(data))^n)
Mord(ap, 3)
Mord(ap, 2)
# Histograma
hist(ap)
# Coeficiente de asimetría
Mcentr(ap, 3) / Mcentr(ap, 2) ^ (3/2)
# Coeficiente de APuntamiento
Mcentr(ap, 4) / Mcentr(ap, 2) ^ 2 - 3
# Covarianza
x <- ap
y <- 1:144
mean(x * y) - mean(x) * mean(y)
cov(x, y) * (length(ap)-1) / length(ap)
# Cuantiles en R
quantile(ap)
quantile(ap, .1)
# Vemos que la interpolación de cuantiles es ligeramente diferente de unos lenguajes de progamación a otros
quantile(1:100, .1)
# Funciones sample y table
xx <- sample(1:10, 100, replace=T)
table(xx)
# Funciones min y max
min(ap)
max(ap)
# Función findInterval para agrupar en intervalos
seq(0, 700, 50)
findInterval(ap, seq(0, 700, 50))
# Tabla de frecuencias de intervalos
50*(findInterval(ap, seq(0, 700, 50))-1)
table(50*(findInterval(ap, seq(0, 700, 50))-1))
# Uso de NA
sum(xx)
sum(xx, na.rm=T)
mean(xx, na.rm=T)
# Indentificación y eliminación de NAs
is.na(xx)
xx[!is.na(xx)]
x <- 1:10
y <- 2 * x + 3 + runif(10, -1, 1)
# función gráfica plot
plot(x, y, xlim=c(0, 11), ylim=c(0, 25), type="p", xlab="puntos x", ylab="puntos y")
# funciones básicas gráficas
abline(3, 2, col="red")
abline(h=5)
abline(v=4, col="blue")
points(c(6,7), c(10,12), col="green")
#representación de funciones
x <- seq(0, 4*pi, .1)
y <- sin(x)
plot(x,y, type="l")
plot(x, y, xlim=c(0, 11), ylim=c(0, 25), type="p", xlab="puntos x", ylab="puntos y")
abline(3, 2, col="red")
abline(h=5)
abline(v=4, col="blue")
points(c(6,7), c(10,12), col="green")
dev.off()
# Creación de un data frame y visualización
df <- data.frame(x=c(1,2,3), y=c("a", "xx", "jo"))
df
View(df)
# 1
densidad <- c(43,55,40,52,39,33,50,33,44,21)
velocidad <- c(27,23.8,30.7,24,34.8,41.4,27,40.4,31.7,51.2)
df <- data.frame(densidad, velocidad)
View(df)
library(ggplot2)
ggplot(df, aes(x=densidad, y=velocidad)) + geom_point()
View(df)
plot(densidad, velocidad)
cov(densidad, velocidad)
cov <- cov(densidad, velocidad)
dX <- sqrt(mean(densidad^2) - mean(densidad)^2)
dY <- sqrt(mean(velocidad^2) - mean(velocidad)^2)
r <- cov/(dX*dY)
cov <- mean(x * y) - mean(x) * mean(y)
cov <- mean(densidad * velocidad) - mean(densidad) * mean(velocidad)
dX <- sqrt(mean(densidad^2) - mean(densidad)^2)
dY <- sqrt(mean(velocidad^2) - mean(velocidad)^2)
r <- cov/(dX*dY)
# Ejercicio 5
valX <- c(43,2,4,65,23)
valY <- c(34,65,8,3,23)
plot(valX, valY)
plot(valX, valY)
cov <- mean(valX * valY) - mean(valX) * mean(valY)
dX <- sqrt(mean(valX^2) - mean(valX)^2)
dY <- sqrt(mean(valY^2) - mean(valY)^2)
r <- cov/(dX*dY)
solve(x-2y=4)
solve(x-2y,4)
solve(x-2y)
log(7)
# Ejercicio 8
sum(densidad)
# Ejercicio 8
sum(densidad +1)
datX <- c(1,2,3,4,5,6,7,8,9,10)
datY <- c(3,10,21,36,55,78,105,136,171,210)
plot(datX, datY)
# Ejercicio 8
x <- c(1,2,3,4,5)
y <- c(3,4.5,7,10,15)
mod1 <- lm(x ~ y)
View(mod1)
coef1 <- mod1$coefficients
coef1
z <- log(y)
mod2 <- lm(z ~ x)
coef2 <- mod2$coefficients
coef1
coef2
coef2 <- exp(mod2$coefficients)
coef2
summary(mod2)
summary(mod2)$r
summary(mod2)$r.squared
summary(mod2)$r.squared
predict.lm(mod1)
predict.lm(mod2)
exp(predict.lm(mod2))
yp2 <- exp(predict.lm(mod2))
yp1 <- predict.lm(mod1)
MSE1 <- mean((y-yp1)^2)
MSE2 <- mean((y-yp2)^2)
varY <- mean(y²)-mean(y)²
varY <- mean(y^2)-mean(y)^2
R21 <- 1 - MSE1/varY
R22 <- 1- MSE2/varY
coef2
4.5*4.5
plor(x,y)
plot(x,y)
coef1
coef2
summary(mod2)$r.squared
R22 <- 1- MSE2/varY
R22
sumary(mod1)$r.squared
summary(mod1)$r.squared
summary(mod1)
summary(mod1)$r
plot(x,y)
yp1 <- predict.lm(mod1)
yp1
yp1
yp2
# Ejercicio 8
x <- c(1,2,3,4,5)
y <- c(3,4.5,7,10,15)
plot(x,y)
# Ejercicio 4
densidad <- c(43,55,40,52,39,33,50,33,44,21)
velocidad <- c(27,23.8,30.7,24,34.8,41.4,27,40.4,31.7,51.2)
plot(densidad, velocidad)
cov <- mean(densidad * velocidad) - mean(densidad) * mean(velocidad)
dX <- sqrt(mean(densidad^2) - mean(densidad)^2)
dY <- sqrt(mean(velocidad^2) - mean(velocidad)^2)
r <- cov/(dX*dY)
r
# Ejercicio 8
x <- c(1,2,3,4,5)
y <- c(3,4.5,7,10,15)
plot(x,y)
mod1 <- lm(x ~ y)
coef1 <- mod1$coefficients
coef1
coef2
z <- log(y)
mod2 <- lm(z ~ x)
coef2 <- exp(mod2$coefficients)
coef2
summary(mod2)
summary(mod2)$r.squared
predict.lm(mod2)
exp(predict.lm(mod2))
mod2 <- lm(z ~ x)
coef2 <- exp(mod2$coefficients)
summary(mod2)$r.squared
# Ejercicio 8
x <- c(1,2,3,4,5)
y <- c(3,4.5,7,10,15)
plot(x,y)
mod1 <- lm(x ~ y)
mod1
summary(mod1)
predict.lm(mod1)
z <- log(y)
mod2 <- lm(z ~ x)
mod2
predict.lm(mod2)
mod1 <- lm(x ~ y)
coef1 <- mod1$coefficients
z <- log(y)
mod2 <- lm(z ~ x)
coef2 <- exp(mod2$coefficients)
summary(mod2)$r.squared
predict.lm(mod2)
exp(predict.lm(mod2))
mod1 <- lm(x ~ y)
coef1 <- mod1$coefficients
z <- log(y)
mod2 <- lm(z ~ x)
coef2 <- exp(mod2$coefficients)
summary(mod2)$r.squared
yp1 <- predict.lm(mod1)
yp2 <- exp(predict.lm(mod2))
MSE1 <- mean((y-yp1)^2)
MSE2 <- mean((y-yp2)^2)
varY <- mean(y^2)-mean(y)^2
R21 <- 1 - MSE1/varY
R22 <- 1- MSE2/varY
yp1
yp2
MSE1
MSE2
varY
yp2
mod2
exp(mod2)
coef2
1:1000
1-2
,3:4
mod1 <- lm(y ~ x ~ x^2)
setwd("~/")
setwd("/home/firez/Universidad/Estadistica/Trabajo R/")
